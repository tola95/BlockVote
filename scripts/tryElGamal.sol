pragma solidity ^0.4.9;

/*
 * @title mortal
 * Functionality for killing contracts
 *  Author: Omotola Babasola
 */
contract mortal {
    /* Define variable owner of the type address*/
    address owner;

    /* this function is executed at initialization and sets the owner of the contract */
    function mortal() { owner = msg.sender; }

    /* Function to recover the funds on the contract */
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}

/*
 * @title tryElGamal
 * Functionality for encrypting and tallying ElGamal commitments
 *  Author: Omotola Babasola
 */
contract tryElGamal is mortal {

    struct Commitment {
        int a;
        int b;
    }

    int public P; /* Prime for the ElGamal Encryption */
    int public Q; /* (P-1)/2 */
    int public G; /* Generator for the encryption, between 1 and P-1 */
    int public H; /* h must be in subgroup of F*p(between 1 and P-1) generated by g */

    Commitment[] public commitments;

    mapping (int => int) public logTable;

    function tryElGamal(int _P, int _G, int _H) {
        P = _P;
        G = _G;
        H = _H;
        Q = (P - 1)/2;
        generateLookupTable();
    }

    function generateLookupTable() private {
        for(int i=0; i<=Q-1; i++){
            logTable[mpmod(G, i, P)] = i;
        }
    }

    function tally() returns (int) {
        Commitment memory a = tallyCommitments();
        return revealCommitment(a.a, a.b, 12);
    }

    /* a= g^r, b= (h^r . g^m) */
    function revealCommitment(int a, int b, int s) returns (int) {
        int As = mpmod(a, -s, P);
        int gm = mpmod(b * As, 1, P);
        return logG(gm);
    }

    function sendCommitment(int a, int b) {
        commitments.push(Commitment({
            a: a,
            b: b
        }));
    }

    function multiplyCommitments(Commitment a, Commitment b) private returns (Commitment memory) {
        Commitment memory prod;
        prod.a = mpmod(a.a * b.a, 1, P);
        prod.b = mpmod(a.b * b.b, 1, P);
        return prod;
    }

    function tallyCommitments() private returns (Commitment memory) {
        if (commitments.length == 0) {
            throw;
        }
        Commitment memory prod = commitments[0];
        for (uint i=1; i<commitments.length; i++) {
            prod = multiplyCommitments(prod, commitments[i]);
        }
        return prod;
    }

    /* base^exponent % modulus */
    function mpmod(int base, int exponent, int modulus) returns (int) {
        if ((base < 1) || (modulus < 1)) {
            throw;
        }
        if (exponent < 0) {
            while (exponent < 0) {
                exponent += ((modulus - 1)/2);
            }
        }
        int result = 1;
        while (exponent > 0) {
            if ((exponent % 2) == 1) {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exponent = exponent / 2;
        }
        return result;
    }

    function logG(int a) returns (int) {
        return logTable[a];
    }

    function verifyZKP(uint x, uint y, uint a1, uint a2,
                        uint b1, uint b2, uint d1, uint d2, int r1, int r2, int challenge)
                         returns (bool) {

        int g_r1_x_d1 = mpmod(mpmod(G, r1, P) * mpmod(x, d1, P), 1, P);
        int h_r1_yG_d1 = mpmod(mpmod(H, r1, P) * mpmod(y * G, d1, P), 1, P);
        int g_r2_x_d2 = mpmod(mpmod(G, r2, P) * mpmod(x, d2, P), 1, P);
        int h_r2_yG_d2 = mpmod(mpmod(H, r2, P) * mpmod(y * mpmod(G, -1, P), d2, P), 1, P);

        return (challenge == d1 + d2) && (a1 == g_r1_x_d1) && (b1 == h_r1_yG_d1) &&
            (a2 == g_r2_x_d2) && (b2 == h_r2_yG_d2);

    }
}